// src/ws.ts
import {
  getSchemaValidator,
  serializeCookie,
  ValidationError
} from "elysia";
import { parseSetCookies } from "elysia/adapter/utils";
import { isNotEmpty } from "elysia/utils";
import {
  createHandleWSResponse,
  createWSMessageParser,
  ElysiaWS
} from "elysia/ws";
function createWebSocketAdapter() {
  const store = {};
  function handler(app, path, options) {
    const { parse, body, response, ...rest } = options;
    const validateMessage = getSchemaValidator(body, {
      // @ts-expect-error private property
      modules: app.definitions.typebox,
      // @ts-expect-error private property
      models: app.definitions.type,
      normalize: app.config.normalize
    });
    const validateResponse = getSchemaValidator(response, {
      // @ts-expect-error private property
      modules: app.definitions.typebox,
      // @ts-expect-error private property
      models: app.definitions.type,
      normalize: app.config.normalize
    });
    const toServerWebSocket = (peer, context) => {
      const ws = peer;
      ws.data = context;
      ws.sendText = ws.send;
      ws.sendBinary = ws.send;
      ws.publishText = ws.publish;
      ws.publishBinary = ws.publish;
      ws.isSubscribed = (topic) => peer.topics.has(topic);
      ws.cork = () => {
        console.log("ws.cork is not supported yet");
      };
      return ws;
    };
    app.route(
      "WS",
      path,
      // @ts-ignore
      async (context) => {
        const { set, path: path2, qi, headers, query, params } = context;
        const id = context.request.wsId;
        context.validator = validateResponse;
        if (options.upgrade) {
          if (typeof options.upgrade === "function") {
            const temp = options.upgrade(context);
            if (temp instanceof Promise) await temp;
          } else if (options.upgrade)
            Object.assign(
              set.headers,
              options.upgrade
            );
        }
        if (set.cookie && isNotEmpty(set.cookie)) {
          const cookie = serializeCookie(set.cookie);
          if (cookie) set.headers["set-cookie"] = cookie;
        }
        if (set.headers["set-cookie"] && Array.isArray(set.headers["set-cookie"]))
          set.headers = parseSetCookies(
            new Headers(set.headers),
            set.headers["set-cookie"]
          );
        const handleResponse = createHandleWSResponse(validateResponse);
        const parseMessage = parse ? createWSMessageParser(parse) : void 0;
        if (typeof options.beforeHandle === "function") {
          const result = options.beforeHandle(context);
          if (result instanceof Promise) await result;
        }
        const errorHandlers = [
          ...options.error ? Array.isArray(options.error) ? options.error : [options.error] : [],
          ...(app.event.error ?? []).map(
            (x) => typeof x === "function" ? x : x.fn
          )
        ].filter((x) => x);
        const handleErrors = errorHandlers.length ? async (ws, error) => {
          for (const handleError of errorHandlers) {
            let response2 = handleError(
              Object.assign(context, { error })
            );
            if (response2 instanceof Promise)
              response2 = await response2;
            await handleResponse(ws, response2);
            if (response2) break;
          }
        } : void 0;
        store[id] = {
          data: context,
          validateResponse,
          ping(ws, data) {
            return options.ping?.(ws, data);
          },
          pong(ws, data) {
            return options.pong?.(ws, data);
          },
          async open(_ws) {
            const ws = toServerWebSocket(_ws, context);
            try {
              await handleResponse(
                ws,
                options.open?.(new ElysiaWS(ws, context))
              );
            } catch (error) {
              handleErrors?.(ws, error);
            }
          },
          async message(ws, message) {
            if (message.includes("ping")) {
              try {
                return void ws.pong(message);
              } catch (error) {
                handleErrors?.(ws, error);
              }
            }
            if (parseMessage)
              message = await parseMessage(ws, message);
            if (message) {
              if (validateMessage?.Check(message) === false)
                return void ws.send(
                  new ValidationError(
                    "message",
                    validateMessage,
                    message
                  ).message
                );
            }
            try {
              await handleResponse(
                ws,
                options.message?.(
                  new ElysiaWS(ws, context, message),
                  message
                )
              );
            } catch (error) {
              handleErrors?.(ws, error);
            }
          },
          async drain(ws) {
            try {
              await handleResponse(
                ws,
                options.drain?.(
                  new ElysiaWS(ws, context)
                )
              );
            } catch (error) {
              handleErrors?.(ws, error);
            }
          },
          async close(ws, code, reason) {
            try {
              await handleResponse(
                ws,
                options.close?.(
                  new ElysiaWS(ws, context),
                  code,
                  reason
                )
              );
            } catch (error) {
              handleErrors?.(ws, error);
            }
          },
          error(ws, error) {
            handleErrors?.(ws, error);
          }
        };
        return "";
      },
      {
        ...rest,
        websocket: options
      }
    );
  }
  return { handler, context: store };
}
export {
  createWebSocketAdapter
};
